from dataclasses import dataclass
from datetime import datetime, timedelta
import json
from typing import Callable, Iterator, Optional, Self

from DarplexAssistant.scripts.start_server import start_server
from DarplexAssistant.scripts.stop_server import stop_server
from ..repository import get_redis_repo, RedisRepository
from ..utils import GameJoinStatus, GameStatusDisplay, Region


class MinecraftServerNotExistsException(Exception):
    pass


class Cache:
    server_status_dicts = dict[tuple[str, Region], dict[str, str]]()
    times = dict[tuple[str, Region], float]()


def cache(func: Callable, timeout: int = 5) -> Callable:
    """Stores cached `RedisRepository.get_server_status_dict` for minimal repo calls.
    If `timeout` exceeded, `server_status_dict` is retrieved and is assigned to the `MinecraftServer`'s name and `Region`"""


    def check_time(server_name: str, key: str, region: Region) -> str:
        if not Cache.times.get((server_name, region)) or not Cache.server_status_dicts.get((server_name, region)): # type: ignore
            Cache.times[(server_name, region)] = datetime.now().timestamp()
            res = func(server_name, key, region)
            with get_redis_repo() as repo:
                Cache.server_status_dicts[(server_name, region)] = repo.get_server_status_dict(server_name, region)
            return res
        now = datetime.now().timestamp()
        difference = now - Cache.times.get((server_name, region), datetime.now().timestamp())
        if difference <= timeout:
            return Cache.server_status_dicts[(server_name, region)][key]
        Cache.times[(server_name, region)] = now
        res = func(server_name, key, region)
        with get_redis_repo() as repo:
            Cache.server_status_dicts[(server_name, region)] = repo.get_server_status_dict(server_name, region)
        return res
    return check_time


@cache
def get_minecraft_server_json_value(server_name: str, key: str, region: Region) -> str:
    """If timeout is active, returns cached key through decorator.
    Otherwise, returns latest ServerStatus json value."""
    with get_redis_repo() as repository:
        response = repository.get_server_status_dict(server_name, region)
    return response.get(key, '-1')


def get_attribute_by_motd(motd: str, attribute: str) -> Optional[str]:
    if motd in ('A Minecraft Server', '-1'):
        return 
    motd_json = json.loads(motd)
    if attribute not in ('_game', '_mode', '_status', '_joinable'):
        return
    return motd_json.get(attribute)


def get_if_exists(server_name: str, region: Region) -> bool:
    with get_redis_repo() as repository:
        return repository.get_if_minecraft_server_exists(server_name, region)


@dataclass
class MinecraftServer:
    """`MinecraftServer` is an instance or node created based on `ServerGroup`.
        - Represents deployed (or alive) Minecraft server.
        - Recognized based on the presence of `serverstatus.minecraft.(REGION).(server)` in Redis.
            - Automatically generated by your -Plex server.
    
    Its properties dynamically updates every 3-5 seconds from when they were last called.
        - Handle through the `cache` method.
        - Properties update every couple seconds of *when they are called*.
    """
    name: str
    _group: str = ''
    _max_ram: int = 0
    _public_address: str = ''
    _port: int = 0
    _start_up_date: Optional[datetime] = None
    _motd: str = ''
    _player_count: int = 0
    _max_player_count: int = 0
    _tps: int = 0
    _ram: int = 0
    _donors_online: int = 0
    _current_time: Optional[datetime] = None
    _is_online: bool = False
    _uptime: Optional[timedelta] = None
    _game: Optional[str] = None
    _mode: Optional[str] = None
    _status: Optional[GameStatusDisplay] = None
    _joinable: Optional[GameJoinStatus] = None
    _exists: bool = False
    region: Region = Region.US

    def __post_init__(self) -> None:
        self._group = self.name.split('-')[0]
        self._max_ram = self.max_ram
        self._public_address = self.public_address
        self._port = self.port
        self._start_up_date = self.start_up_date
        self._motd = self.motd
        self._player_count = self.player_count
        self._max_player_count = self.max_player_count
        self._tps = self.tps
        self._ram = self.ram
        self._donors_online = self.donors_online
        self._current_time = self.current_time
        self._is_online = self.is_online
        self._uptime = self.uptime
        self._game = self.game
        self._mode = self.mode
        self._status = self.status
        self._joinable = self.joinable
        self._exists = self.exists

    @property
    def group(self) -> str:
        self._group = self.name.split('-')[0]
        return self._group

    @property
    def max_ram(self) -> int:
        self._max_ram = int(get_minecraft_server_json_value(self.name, '_maxRam', self.region))
        return self._max_ram

    @property
    def public_address(self) -> str:
        self._public_address = get_minecraft_server_json_value(self.name, '_publicAddress', self.region)
        return self._public_address

    @property
    def port(self) -> int:
        self._port = int(get_minecraft_server_json_value(self.name, '_port', self.region))
        return self._port

    @property
    def start_up_date(self) -> Optional[datetime]:
        if not self.exists:
            return None
        self._start_up_date = datetime.fromtimestamp(int(get_minecraft_server_json_value(self.name, '_startUpDate', self.region)))
        return self._start_up_date 

    @property
    def motd(self) -> str:
        self._motd = get_minecraft_server_json_value(self.name, '_motd', self.region)
        return self._motd

    @property
    def player_count(self) -> int:
        self._player_count = int(get_minecraft_server_json_value(self.name, '_playerCount', self.region))
        return self._player_count

    @property
    def max_player_count(self) -> int:
        self._max_player_count = int(get_minecraft_server_json_value(self.name, '_maxPlayerCount', self.region))
        return self._max_player_count

    @property
    def tps(self) -> int:
        self._tps = int(get_minecraft_server_json_value(self.name, '_tps', self.region))
        return self._tps

    @property
    def ram(self) -> int:
        self._ram = int(get_minecraft_server_json_value(self.name, '_ram', self.region))
        return self._ram

    @property
    def donors_online(self) -> int:
        self._donors_online = int(get_minecraft_server_json_value(self.name, '_donorsOnline', self.region))
        return self._donors_online

    @property
    def current_time(self) -> Optional[datetime]:
        if not self.exists:
            return None 
        self._current_time = datetime.fromtimestamp(int(get_minecraft_server_json_value(self.name, '_currentTime', self.region)) / 1000)
        return self._current_time

    @property
    def is_online(self) -> bool:
        if not self.current_time:
            return False
        self._is_online = datetime.now().timestamp() - self.current_time.timestamp() <= 10000 
        return self._is_online

    @property
    def uptime(self) -> Optional[timedelta]:
        if not self.current_time or not self.start_up_date:
            return None
        return self.current_time - self.start_up_date

    @property
    def game(self) -> Optional[str]:
        self._game = get_attribute_by_motd(self.motd, '_game')
        return self._game

    @property
    def mode(self) -> Optional[str]:
        self._mode = get_attribute_by_motd(self.motd, '_mode')
        return self._mode

    @property
    def status(self) -> Optional[GameStatusDisplay]:
        self._status = None if self.motd in ('A Minecraft Server', '-1') else \
                GameStatusDisplay(get_attribute_by_motd(self.motd, '_status'))
        return self._status

    @property
    def joinable(self) -> Optional[GameJoinStatus]:
        self._joinable = None if self.motd in ('A Minecraft Server', '-1') else \
                GameJoinStatus(get_attribute_by_motd(self.motd, '_joinable'))
        return self._joinable

    @property
    def exists(self) -> bool:
        self._exists = get_if_exists(self.name, self.region)
        return self._exists
    
    def deploy_server(self) -> None:
        """Starts up `MinecraftServer`"""
        if not self.exists:
            raise MinecraftServerNotExistsException
        start_server(*self.start_server_params()) # type: ignore

    def kill_server(self) -> None:
        """Stops the `MinecraftServer`"""
        stop_server(self.name)

    def start_server_params(self) -> Optional[tuple[bool | str | int, ...]]:
        """Returns params necessary to start server."""
        with get_redis_repo() as repository:
            if not repository.server_group_exists(self.group): # unlikely, but good edge case to check 
                return 
            data: dict[str, str] = repository.get_server_group_dict(self.group).copy()
        zip_file = data.get('worldZip', '')
        plugin_file = data.get('plugin', '')
        config_path = data.get('configPath', '')
        is_us = data.get('region', 'US') == 'US'
        add_anticheat = data.get('addNoCheat') == 'true'
        add_worldedit = data.get('addWorldEdit') == 'true'
        return (self.port,
                self.max_ram,
                zip_file,
                plugin_file,
                config_path,
                self.group,
                self.name,
                is_us,
                add_anticheat,
                add_worldedit)

    def get_create_cmd(self) -> str:
        with get_redis_repo() as repository:
            if not repository.server_group_exists(self.group): # unlikely, but good edge case to check 
                return ''
            data: dict[str, str] = repository.get_server_group_dict(self.group)
        output = (f'python3 startServer.py 127.0.0.1 127.0.0.1 {self.port}'
                  f' {self.max_ram}'
                  f' {data.get("worldZip")}'
                  f' {data.get("plugin")}'
                  f' {data.get("configPath")}'
                  f' {self.group}'
                  f' {self.name}'
                  f' {str(data.get("region", "US") == "US").lower()}'
                  f' {str(data.get("addNoCheat") == "true").lower()}'
                  f' {str(data.get("addWorldEdit") == "true").lower()}')
        return output

    def get_delete_cmd(self) -> str:
        return f'python3 stopServer.py 127.0.0.1 {self.name}'
    
    def _needs_restart(self) -> bool:
        return self.is_online and ('Restarting' in self.motd 
                                   or 'Finished' in self.motd)

    def __hash__(self) -> int:
        return hash(self.name)

    def __eq__(self: Self, other) -> bool:
        if not isinstance(other, Self):
            return False
        return hash(self) == hash(other)

    @classmethod
    def convert_to_minecraft_server(cls, server: str, region: Region) -> Self:
        """
        Converts to `MinecraftServer` from existing ServerStatus cache.
        Will return `MinecraftServerNotExistsException` if DNE.

        """
        with get_redis_repo() as repository:
            minecraft_server: dict[str, str] = repository.get_server_status_dict(server, region)
        name: Optional[str] = None
        if minecraft_server is None or (name := minecraft_server.get('_name')) is None:
            raise MinecraftServerNotExistsException()
        return cls(
            name = name,
            region = region,
        )


def extract_region_from_server_status_key(server_status_key: str) -> Region:
    """Parses region from ServerStatus key into `Region` object."""
    assert (isinstance(server_status_key, str) and len(server_status_key.split('.')) == 4), 'Server Status Key must be str and must match appropriate format.'
    matched_region = server_status_key.split('.')[2]
    return next((region 
                 for region in Region
                 if region.value == matched_region), Region.US)


def get_minecraft_servers_by_prefix(prefix: str, region: Region) -> Iterator[MinecraftServer]:
    """Fetches MinecraftServer under matching prefix and `Region`.
    If region equals `Region.ALL`, returns `MinecraftServer`s for all regions."""
    with get_redis_repo() as repository:
        yield from (MinecraftServer.convert_to_minecraft_server(server, extract_region_from_server_status_key(server))
                for server in repository.iterate_minecraft_servers_by_group(prefix, region))

